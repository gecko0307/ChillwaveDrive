/*
Copyright (c) 2021-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module main;

import std.stdio;
import std.conv;
import std.meta;
import std.math;
import std.random;
import dagon;
import dagon.ext.newton;
import soloud;
import vehicle;
import wheel;
import view;

float normalizeInRange(float x, float xmin, float xmax)
{
    return clamp((x - xmin) / (xmax - xmin), 0.0f, 1.0f);
}

import dlib.serialization.json;

class JSONAsset: Asset
{
    String str;
    JSONDocument doc;
    
    this(Owner o)
    {
        super(o);
    }

    ~this()
    {
        release();
    }

    override bool loadThreadSafePart(string filename, InputStream istrm, ReadOnlyFileSystem fs, AssetManager mngr)
    {
        str = String(istrm);
        doc = New!JSONDocument(str.toString);
        return true;
    }
    
    override bool loadThreadUnsafePart()
    {
        return true;
    }

    override void release()
    {
        if (doc)
            Delete(doc);
        str.free();
    }
}

float jsonPropFloat(JSONValue val, string name, float defaultValue)
{
    if (name in val.asObject)
        return val.asObject[name].asNumber;
    else
        return defaultValue;
}

uint jsonPropUInt(JSONValue val, string name, uint defaultValue)
{
    if (name in val.asObject)
        return cast(uint)val.asObject[name].asNumber;
    else
        return defaultValue;
}

string jsonPropString(JSONValue val, string name, string defaultValue)
{
    if (name in val.asObject)
        return val.asObject[name].asString;
    else
        return defaultValue;
}

Vector3f jsonPropVector(JSONValue val, string name, Vector3f defaultValue)
{
    if (name in val.asObject)
        return val.asObject[name].asVector;
    else
        return defaultValue;
}

class GameScene: Scene
{
    FontAsset aFontDroidSans14;
    
    VehicleDemoGame game;
    Soloud audio;
    
    GLTFAsset aTrack;
    
    Camera camera;
    VehicleViewComponent vehicleView;
    
    NewtonPhysicsWorld physicsWorld;
    
    JSONAsset aCar;
    
    GLTFAsset aChassis;
    GLTFAsset aWindows;
    Array!GLTFAsset aWheels;
    
    Entity eCar;
    Array!Entity eWheels;
    Vehicle car;
    
    TextureAsset aTexParticleDust;
    
    TextureAsset aEnvmap;
    
    Light sun;
    
    ParticleSystem particleSystem;
    Emitter emitterLeft;
    Emitter emitterRight;
    
    bool headlightsPressed = false;
    bool headlightsOn = true;
    float headlightsEnergy = 5.0f;
    Material headlightsMaterial;
    Light light1, light2, light1_vol, light2_vol;
    
    Color4f ambientClearSkyDay = Color4f(0.4f, 0.4f, 0.7f, 1.0f);
    Color4f ambientClearSkySunset = Color4f(0.6f, 0.4f, 0.7f, 1.0f);
    Color4f ambientClearSkyNight = Color4f(0.3f, 0.3f, 0.6f, 1.0f);
    
    Color4f ambientCloudySkyDay = Color4f(0.4f, 0.4f, 0.5f, 1.0f);
    Color4f ambientCloudySkySunset = Color4f(0.6f, 0.3f, 0.3f, 1.0f);
    Color4f ambientCloudySkyNight = Color4f(0.4f, 0.4f, 0.7f, 1.0f);
    
    Color4f fogDay = Color4f(0.4f, 0.5f, 0.7f, 1.0f);
    Color4f fogSunset = Color4f(0.6f, 0.4f, 0.7f, 1.0f);
    Color4f fogNight = Color4f(0.0f, 0.0f, 0.0f, 1.0f);
    
    UIWidget overlay;

    WavStream music;
    WavStream sfxAmbient;
    Wav sfxEngine1;
    Wav sfxEngine2;
    Wav sfxSteer;
    Wav sfxWheels;
    Wav sfxSqueal;
    Wav[2] sfxSuspension;
    Wav[2] sfxHit;
    Wav sfxCamera;
    
    int musicVoice;
    int engine1Voice;
    int engine2Voice;
    int steerVoice;
    int wheelsVoice;
    int squealVoice;
    int hitVoice;
    int suspVoice;
    
    float musicVolume = 0.5f;
    float sfxVolume = 0.5f;

    this(VehicleDemoGame game)
    {
        super(game);
        this.game = game;
        this.audio = game.audio;
    }
    
    ~this()
    {
        aWheels.free();
        eWheels.free();
    }

    override void beforeLoad()
    {
        aFontDroidSans14 = addFontAsset("data/font/DroidSans.ttf", 14);
        
        aEnvmap = addTextureAsset("data/envmaps/rural_evening_road_4k.hdr");
        
        // Track
        aTrack = addGLTFAsset("data/track/racetrack.gltf");
        
        // Car
        aCar = New!JSONAsset(assetManager);
        assetManager.preloadAsset(aCar, "data/cars/mclaren_gt/mclaren_gt.json");
        
        string chassisFilename;
        auto root = aCar.doc.root.asObject;
        if ("chassis" in root)
        {
            auto chassis = root["chassis"];
            chassisFilename = jsonPropString(chassis, "model", "");
        }
        
        if (chassisFilename.length)
            aChassis = addGLTFAsset(chassisFilename);
        
        if ("windows" in root)
        {
            auto windows = root["windows"];
            string windowsFilename = jsonPropString(windows, "model", "");
            if (windowsFilename.length)
                aWindows = addGLTFAsset(windowsFilename);
        }
        
        if ("wheels" in root)
        {
            auto wheels = root["wheels"].asArray;
            foreach(wheel; wheels)
            {
                string wheelFilename = jsonPropString(wheel, "model", "");
                auto aWheel = addGLTFAsset(wheelFilename);
                aWheels.append(aWheel);
            }
        }
        
        aTexParticleDust = addTextureAsset("data/particles/dust.png");
        
        // Sounds
        sfxEngine1 = Wav.create();
        sfxEngine1.load("data/sounds/engine.wav");
        sfxEngine1.set3dDistanceDelay(true);
        
        sfxEngine2 = Wav.create();
        sfxEngine2.load("data/sounds/engine2.wav");
        sfxEngine2.set3dDistanceDelay(true);
        
        sfxSteer = Wav.create();
        sfxSteer.load("data/sounds/steer.wav");
        sfxSteer.set3dDistanceDelay(true);
        
        sfxWheels = Wav.create();
        sfxWheels.load("data/sounds/wheels.wav");
        sfxWheels.set3dDistanceDelay(true);
        
        sfxSqueal = Wav.create();
        sfxSqueal.load("data/sounds/squeal.wav");
        sfxSqueal.set3dDistanceDelay(true);
        
        sfxSuspension[0] = Wav.create();
        sfxSuspension[0].load("data/sounds/suspension1.wav");
        sfxSuspension[0].set3dDistanceDelay(true);
        
        sfxSuspension[1] = Wav.create();
        sfxSuspension[1].load("data/sounds/suspension2.wav");
        sfxSuspension[1].set3dDistanceDelay(true);
        
        sfxHit[0] = Wav.create();
        sfxHit[0].load("data/sounds/hit1.wav");
        sfxHit[0].set3dDistanceDelay(true);
        
        sfxHit[1] = Wav.create();
        sfxHit[1].load("data/sounds/hit2.wav");
        sfxHit[1].set3dDistanceDelay(true);
        
        sfxCamera = Wav.create();
        sfxCamera.load("data/sounds/camera.wav");
        sfxCamera.set3dDistanceDelay(true);
        
        sfxAmbient = WavStream.create();
        sfxAmbient.load("data/sounds/ambient.mp3");
        
        music = WavStream.create();
        music.load("data/music/stellar_escape.mp3");
    }

    override void afterLoad()
    {
        environment.backgroundColor = Color4f(0.05f, 0.1f, 0.2f, 1.0f);
        environment.fogColor = environment.backgroundColor;
        environment.fogStart = 0.0f;
        environment.fogEnd = 400.0f;
        
        physicsWorld = New!NewtonPhysicsWorld(eventManager, assetManager);
        version(Windows) physicsWorld.loadPlugins(".");
        
        camera = addCamera();
        camera.fov = 40.0f;
        game.renderer.activeCamera = camera;
        
        sun = addLight(LightType.Sun);
        //sun.color = Color4f(1.0f, 0.95f, 0.9f, 1.0f);
        sun.color = Color4f(1.0f, 0.4f, 0.3f, 1.0f);
        sun.shadowEnabled = true;
        sun.energy = 2.0f;
        sun.turn(-10.0f); //0.0f
        sun.pitch(-10.0f); //-30.0f
        sun.scatteringEnabled = true;
        sun.scattering = 0.2f;
        sun.mediumDensity = 0.25f;
        sun.scatteringUseShadow = false;
        sun.scatteringMaxRandomStepOffset = 0.5f;
        environment.sun = sun;
        
        Texture cubemap = generateCubemap(1024, aEnvmap.texture, null);
        Texture prefilteredCubemap = prefilterCubemap(1024, cubemap, assetManager);
        Delete(cubemap);
        
        environment.ambientMap = prefilteredCubemap;
        environment.ambientEnergy = 0.25f;
        
        auto eSky = addEntity();
        auto psync = New!PositionSync(eventManager, eSky, camera);
        eSky.drawable = New!ShapeBox(Vector3f(1.0f, 1.0f, 1.0f), assetManager);
        eSky.scaling = Vector3f(100.0f, 100.0f, 100.0f);
        eSky.layer = EntityLayer.Background;
        eSky.material = New!Material(assetManager);
        eSky.material.depthWrite = false;
        eSky.material.useCulling = false;
        eSky.material.baseColorTexture = prefilteredCubemap;
        eSky.material.linearColor = true;
        eSky.material.emissionEnergy = 0.25f;
        eSky.gbufferMask = 0.0f;
        
        // Track
        aTrack.markTransparentEntities();
        useEntity(aTrack.rootEntity);
        foreach(node; aTrack.nodes)
        {
            useEntity(node.entity);
        }
        foreach(mat; aTrack.materials)
        {
            mat.useCulling = false;
        }
        
        auto eTrack = addEntity();
        auto trackShape = New!NewtonMeshShape(aTrack, physicsWorld);
        eTrack.makeStaticBody(physicsWorld, trackShape);
        
        // Car
        eCar = addEntity();
        eCar.position = Vector3f(0.0f, 0.65f, 0.0f);
        eCar.turn(90.0f);
        eCar.blurMask = 0.0f;
        
        auto root = aCar.doc.root;
        
        NewtonCompoundShape chassisShape = null;
        
        if ("chassis" in root.asObject)
        {
            auto chassis = root.asObject["chassis"].asObject;
            
            auto dg = New!DrawableGroup(assetManager);
            foreach(mesh; aChassis.meshes.data)
            {
                dg.add(mesh);
            }
            eCar.drawable = dg;
            
            if ("materials" in chassis)
            {
                auto materials = chassis["materials"];
                
                if ("headlights" in materials.asObject)
                {
                    string headlightsMaterialName = jsonPropString(materials, "headlights", "");
                    if (headlightsMaterialName.length)
                    {
                        headlightsMaterial = aChassis.material(headlightsMaterialName);
                        headlightsMaterial.emissionEnergy = headlightsEnergy;
                    }
                }
            }
            
            if ("hitboxes" in chassis)
            {
                if (chassis["hitboxes"].asArray.length > 0)
                {
                    Array!NewtonCollisionShape hitboxShapes;
                    foreach(hitbox; chassis["hitboxes"].asArray)
                    {
                        Vector3f hitboxSize = jsonPropVector(hitbox, "size", Vector3f(1.0f, 1.0f, 1.0f));
                        Vector3f hitboxPosition = jsonPropVector(hitbox, "position", Vector3f(0.0f, 0.0f, 0.0f));
                        auto shape = New!NewtonBoxShape(hitboxSize, physicsWorld);
                        shape.setTransformation(translationMatrix(hitboxPosition));
                        hitboxShapes.append(shape);
                    }
                    chassisShape = New!NewtonCompoundShape(hitboxShapes.data, physicsWorld);
                }
            }
        }
        
        if (aWindows)
        {
            auto eWindows = addEntity(eCar);
            auto dg = New!DrawableGroup(assetManager);
            foreach(mesh; aWindows.meshes.data)
            {
                dg.add(mesh);
            }
            eWindows.drawable = dg;
            eWindows.transparent = true;
            eWindows.castShadow = false;
            eWindows.blurMask = 0.0f;
        }
        
        float carMass = jsonPropFloat(root, "facing", 1500.0f);
        Vector3f carInertia = jsonPropVector(root, "inertia", Vector3f(1.0f, 1.0f, 1.0f));
        
        car = New!Vehicle(physicsWorld, eCar, chassisShape, carMass, 1);
        car.setInertia(carMass, boxInertia(carInertia, carMass));
        car.chassisBody.centerOfMass = jsonPropVector(root, "centerOfMass", Vector3f(0.0f, 0.0f, 0.0f));
        car.maxSteeringAngle = jsonPropFloat(root, "maxSteeringAngle", 45.0f);
        car.maxTorque = jsonPropFloat(root, "maxTorque", 500.0f);
        
        if ("wheels" in root.asObject)
        {
            auto wheels = root.asObject["wheels"].asArray;
            foreach(i, wheel; wheels)
            {
                auto aWheel = aWheels[i];
                
                float wheelRadius = jsonPropFloat(wheel, "radius", 0.337f);
                float facing = jsonPropFloat(wheel, "facing", -1.0f);
                
                Vector3f suspensionPosition = Vector3f(-0.75f, 0.2f, +1.35f);
                float suspensionMaxLength = 0.3f;
                float suspensionStiffness = 100.0f;
                float suspensionDamping = 10.0f;
                
                if ("suspension" in wheel.asObject)
                {
                    auto suspension = wheel.asObject["suspension"];
                    suspensionPosition = jsonPropVector(suspension, "position", suspensionPosition);
                    suspensionMaxLength = jsonPropFloat(suspension, "maxLength", suspensionMaxLength);
                    suspensionStiffness = jsonPropFloat(suspension, "stiffness", suspensionStiffness);
                    suspensionDamping = jsonPropFloat(suspension, "damping", suspensionDamping);
                }
                
                float tyreLateralFriction = 0.75f;
                float tyreLongitudinalFriction = 1.0f;
                
                if ("tyre" in wheel.asObject)
                {
                    auto tyre = wheel.asObject["tyre"];
                    tyreLateralFriction = jsonPropFloat(tyre, "lateralFriction", tyreLateralFriction);
                    tyreLongitudinalFriction = jsonPropFloat(tyre, "longitudinalFriction", tyreLongitudinalFriction);
                }
                
                Wheel pWheel = car.addWheel(suspensionPosition, wheelRadius, facing);
                pWheel.load = jsonPropFloat(wheel, "loadSplit", 0.25f);
                pWheel.torqueSplitRatio = jsonPropFloat(wheel, "torqueSplit", 0.0f);
                pWheel.camberAngle = jsonPropFloat(wheel, "camberAngle", 0.0f);
                pWheel.lateralDynamicFrictionCoefficient = tyreLateralFriction;
                pWheel.longitudinalDynamicFrictionCoefficient = tyreLongitudinalFriction;
                pWheel.suspension.maxLength = suspensionMaxLength;
                pWheel.suspension.stiffness = suspensionStiffness;
                pWheel.suspension.damping = suspensionDamping;
                
                Entity eWheel = addEntity(eCar);
                auto dg = New!DrawableGroup(assetManager);
                foreach(mesh; aWheel.meshes.data)
                {
                    dg.add(mesh);
                }
                eWheel.drawable = dg;
                eWheel.position = pWheel.localWheelPosition;
                eWheel.blurMask = 0.0f;
                eWheels.append(eWheel);
            }
        }
        
        // Headlights (TODO: load from car asset)
        light1 = addLight(LightType.Spot, eCar);
        light1.volumeRadius = 10.0f;
        light1.energy = 30.0f;
        light1.spotOuterCutoff = 45.0f;
        light1.position = Vector3f(-0.6f, 0.0f, 2.0f);
        light1.turn(180);
        
        light2 = addLight(LightType.Spot, eCar);
        light2.volumeRadius = 10.0f;
        light2.energy = 30.0f;
        light2.spotOuterCutoff = 45.0f;
        light2.position = Vector3f(0.6f, 0.0f, 2.0f);
        light2.turn(180);
        
        light1_vol = addLight(LightType.AreaSphere, eCar);
        light1_vol.volumeRadius = 10.0f;
        light1_vol.energy = 8.0f;
        light1_vol.volumeRadius = 1.0f;
        light1_vol.scatteringEnabled = true;
        light1_vol.mediumDensity = 0.5f;
        light1_vol.position = Vector3f(-0.65f, 0.2f, 1.9f);
        
        light2_vol = addLight(LightType.AreaSphere, eCar);
        light2_vol.volumeRadius = 10.0f;
        light2_vol.energy = 8.0f;
        light2_vol.volumeRadius = 1.0f;
        light2_vol.scatteringEnabled = true;
        light2_vol.mediumDensity = 0.5f;
        light2_vol.position = Vector3f(0.65f, 0.2f, 1.9f);
        
        light1.shining = headlightsOn;
        light2.shining = headlightsOn;
        light1_vol.shining = headlightsOn;
        light2_vol.shining = headlightsOn;
        
        auto eParticles = addEntity();
        particleSystem = New!ParticleSystem(eventManager, eParticles);
        
        // Dust particle systems
        auto mParticlesDust = addMaterial();
        mParticlesDust.baseColorTexture = aTexParticleDust.texture;
        mParticlesDust.blendMode = Transparent;
        mParticlesDust.depthWrite = false;
        mParticlesDust.sun = sun;
        mParticlesDust.opacity = 0.2f;
        mParticlesDust.useShadows = true;

        auto eParticlesRight = addEntity(eCar);
        emitterRight = New!Emitter(eParticlesRight, particleSystem, 30);
        eParticlesRight.position = Vector3f(-0.9f, 0.0f, -0.8f);
        emitterRight.minLifetime = 1.0f;
        emitterRight.maxLifetime = 3.0f;
        emitterRight.minSize = 0.5f;
        emitterRight.maxSize = 1.0f;
        emitterRight.minInitialSpeed = 0.2f;
        emitterRight.maxInitialSpeed = 0.2f;
        emitterRight.scaleStep = Vector2f(2, 2);
        emitterRight.material = mParticlesDust;
        eParticlesRight.castShadow = false;
        eParticlesRight.visible = true;

        auto eParticlesLeft = addEntity(eCar);
        emitterLeft = New!Emitter(eParticlesLeft, particleSystem, 30);
        eParticlesLeft.position = Vector3f(0.9f, 0.0f, -0.8f);
        emitterLeft.minLifetime = 1.0f;
        emitterLeft.maxLifetime = 3.0f;
        emitterLeft.minSize = 0.5f;
        emitterLeft.maxSize = 1.0f;
        emitterLeft.minInitialSpeed = 0.2f;
        emitterLeft.maxInitialSpeed = 0.2f;
        emitterLeft.scaleStep = Vector2f(2, 2);
        emitterLeft.material = mParticlesDust;
        eParticlesLeft.castShadow = false;
        eParticlesLeft.visible = true;
        
        vehicleView = New!VehicleViewComponent(eventManager, camera, car);
        eventManager.showCursor(false);
        
        auto ambientVoice = audio.play(sfxAmbient);
        audio.setLooping(ambientVoice, true);
        audio.setVolume(ambientVoice, sfxVolume);
        
        engine1Voice = audio.play3d(sfxEngine1, car.position.x, car.position.y, car.position.z);
        audio.setLooping(engine1Voice, true);
        audio.set3dSourceMinMaxDistance(engine1Voice, 1.0f, 50.0f);
        audio.setVolume(engine1Voice, sfxVolume);
        
        engine2Voice = audio.play3d(sfxEngine2, car.position.x, car.position.y, car.position.z);
        audio.setLooping(engine2Voice, true);
        audio.set3dSourceMinMaxDistance(engine2Voice, 1.0f, 50.0f);
        audio.setVolume(engine2Voice, sfxVolume);
        
        steerVoice = audio.play3d(sfxSteer, car.position.x, car.position.y, car.position.z);
        audio.setLooping(steerVoice, true);
        audio.set3dSourceMinMaxDistance(steerVoice, 1.0f, 50.0f);
        audio.setVolume(steerVoice, sfxVolume);
        
        wheelsVoice = audio.play3d(sfxWheels, car.position.x, car.position.y, car.position.z);
        audio.setLooping(wheelsVoice, true);
        audio.set3dSourceMinMaxDistance(wheelsVoice, 1.0f, 50.0f);
        audio.setVolume(wheelsVoice, sfxVolume);
        
        squealVoice = audio.play3d(sfxSqueal, car.position.x, car.position.y, car.position.z);
        audio.setVolume(squealVoice, sfxVolume);
        audio.setLooping(squealVoice, true);
        
        audio.update3dAudio();
        
        text = New!TextLine(aFontDroidSans14.font, "0", assetManager);
        text.color = Color4f(0.0f, 0.0f, 0.0f, 0.5f);
        auto eText = addEntityHUD();
        eText.drawable = text;
        eText.position = Vector3f(16.0f, 30.0f, 0.0f);
        
        overlay = addWidget!UIWidget();
        overlay.backgroundFocusedColor = overlay.backgroundUnfocusedColor =
            Color4f(1.0f, 1.0f, 1.0f, 1.0f);
        overlay.width = eventManager.windowWidth;
        overlay.height = eventManager.windowHeight;
        overlay.fitToParent = true;
        overlay.background.opacity = 0.0f;
        
        car.arcadeSteering = true;
        
        game.deferred.passLight.volumetricScatteringEnabled = true;
    }
    
    TextLine text;
    
    override void onKeyDown(int key)
    {
        if (key == KEY_ESCAPE)
            application.exit();
        else if (key == KEY_M)
        {
            if (audio.isValidVoiceHandle(musicVoice))
            {
                audio.stop(musicVoice);
            }
            else
            {
                musicVoice = audio.play(music);
                audio.setLooping(musicVoice, true);
                audio.setVolume(musicVoice, musicVolume);
            }
        }
        else if (key == KEY_RETURN)
        {
            
        }
    }
    
    override void onMouseButtonUp(int button)
    {
        if (button == MB_LEFT)
        {
            vehicleView.active = !vehicleView.active;
            eventManager.showCursor(!vehicleView.active);
        }
        else if (button == MB_RIGHT)
        {
            auto shotVoice = audio.play(sfxCamera);
            audio.setVolume(shotVoice, sfxVolume);
            application.takeScreenshot("screenshots/screenshot");
            overlay.background.opacity = 1.0f;
            overlay.background.fadeOut(0.25f);
        }
    }
    
    float lastDirection = 0.0f;
    
    float accelerationPressed = false;
    float carEngineSoundSpeed = 1.0f;
    
    float triggerForward = 0.0f;
    float triggerBackward = 0.0f;
    override void onControllerAxisMotion(uint deviceIndex, int axis, float value)
    {
        if (axis == GA_TRIGGERRIGHT)
        {
            triggerForward = value;
        }
        else if (axis == GA_TRIGGERLEFT)
        {
            triggerBackward = value;
        }
    }
    
    float joystickSteer = 0.0f;
    override void onJoystickAxisMotion(uint deviceIndex, int axis, float value)
    {
        joystickSteer = -value;
    }
    
    bool joystickForward = false;
    bool joystickBack = false;
    override void onJoystickButtonDown(uint deviceIndex, int button)
    {
        if (button == 1)
        {
            joystickForward = true;
        }
        else if (button == 0)
        {
            joystickBack = true;
        }
    }
    
    override void onJoystickButtonUp(uint deviceIndex, int button)
    {
        if (button == 1)
        {
            joystickForward = false;
        }
        else if (button == 0)
        {
            joystickBack = false;
        }
    }
    
    float steeringInputPrev = 0.0f;
    
    override void onUpdate(Time t)
    {
        // Car controls
        if (inputManager.getButton("forward") || joystickForward)
            car.accelerate(1.0f, 2.0f * t.delta);
        else if (inputManager.getButton("back") || joystickBack)
            car.accelerate(-1.0f, 2.0f * t.delta);
        else if (triggerForward > 0.0f)
            car.accelerate(1.0f, 2.0f * triggerForward * t.delta);
        else if (triggerBackward > 0.0f)
            car.accelerate(-1.0f, 2.0f * triggerBackward * t.delta);
        else
            car.idle();
        
        carEngineSoundSpeed = lerp(1.0f, 1.5f, car.throttle);
        
        if (car.arcadeSteering)
        {
            float axis = inputManager.getAxis("horizontal");
            car.steer(-axis * 5.0f * t.delta);
        }
        else
            car.manualSteer(joystickSteer);
        
        // Headlights on/off
        if (inputManager.getButton("headlights"))
        {
            if (!headlightsPressed)
            {
                headlightsPressed = true;
                headlightsOn = !headlightsOn;
                light1.shining = headlightsOn;
                light2.shining = headlightsOn;
                light1_vol.shining = headlightsOn;
                light2_vol.shining = headlightsOn;
                if (headlightsMaterial)
                {
                    if (headlightsOn)
                        headlightsMaterial.emissionEnergy = headlightsEnergy;
                    else
                        headlightsMaterial.emissionEnergy = 0.0f;
                }
            }
        }
        else
        {
            headlightsPressed = false;
        }
        
        // Rotate wheels
        foreach(i, w; eWheels)
        {
            w.position = car.wheels[i].localWheelPosition;
            w.rotation = car.wheels[i].localRotation;
        }
        
        car.update(t);
        
        float speedKMH = car.speedKMH();
        
        // Engine sound
        audio.set3dSourcePosition(engine1Voice, car.position.x, car.position.y, car.position.z);
        float newRpmFactor = clamp((car.rpm - 800.0f) / (6500.0f - 800.0f), 0.0f, 1.0f);
        rpmFactor += (newRpmFactor - rpmFactor) * 0.9f;
        float engineSoundSpeed = lerp(1.0f, 1.8f, rpmFactor);
        audio.setRelativePlaySpeed(engine1Voice, engineSoundSpeed);
        
        audio.set3dSourcePosition(engine2Voice, car.position.x, car.position.y, car.position.z);
        float engine2SoundSpeed = lerp(0.5f, 1.0f, rpmFactor);
        audio.setRelativePlaySpeed(engine2Voice, engineSoundSpeed);
        float engine2Volume = lerp(0.25f, 1.0f, rpmFactor * rpmFactor * rpmFactor);
        audio.setVolume(engine2Voice, sfxVolume * engine2Volume);
        
        // Tire squeal sound
        float lateralSlip = car.lateralSlip;
        float longitudinalSlip = car.longitudinalSlip;
        float squealVolume = clamp(lateralSlip, 0.0f, 1.0f);
        if (car.brake) squealVolume = clamp((speedKMH - 10.0f) / 10.0f, 0.0f, 1.0f);
        audio.setVolume(squealVoice, sfxVolume * squealVolume * 0.8f);
        audio.set3dSourcePosition(squealVoice, car.position.x, car.position.y, car.position.z);
        
        // Wheels sound
        float wheelsVolume = 0.0f;
        if (!car.brake)
        {
            if (speedKMH <= 1.0f)
                wheelsVolume = clamp(speedKMH, 0.0f, 1.0f);
            else
                wheelsVolume = 1.0f - clamp((speedKMH - 1.0f) / 30.0f, 0.0f, 1.0f);
            wheelsVolume *= (1.0f - squealVolume);
        }
        float wheelsSoundSpeed = lerp(0.7f, 1.2f, clamp((speedKMH - 30.0f) / 30.0f, 0.0f, 1.0f));
        audio.setVolume(wheelsVoice, sfxVolume * wheelsVolume);
        audio.setRelativePlaySpeed(wheelsVoice, wheelsSoundSpeed);
        
        float steerVolume = cast(float)(abs(car.steeringInput - steeringInputPrev) > 0.01f) * 0.3f;
        steerVolume *= 1.0f - clamp((speedKMH - 1.0f) / 30.0f, 0.0f, 1.0f);
        audio.setVolume(steerVoice, sfxVolume * steerVolume);
        steeringInputPrev = car.steeringInput;
        
        foreach(w; car.wheels)
        {
            float lengthDiff = abs(w.suspension.length - w.suspension.lengthPrev);
            if (lengthDiff > 0.01f)
            {
                if (!cast(bool)audio.isValidVoiceHandle(suspVoice))
                {
                    suspVoice = audio.play3d(sfxSuspension[uniform(0, $)], car.position.x, car.position.y, car.position.z);
                    audio.setVolume(suspVoice, 0.5f * sfxVolume);
                }
            }
        }
        
        // Dust particles
        bool makingDust = lateralSlip > 0.0f || car.brake;
        if (makingDust && car.wheels[2].onGround) emitterLeft.emitting = true;
        else emitterLeft.emitting = false;
        if (makingDust && car.wheels[3].onGround) emitterRight.emitting = true;
        else emitterRight.emitting = false;
        
        physicsWorld.update(t.delta);
        
        // Cool effect
        float speedFactor = clamp((speedKMH - 120.0f) / 80.0f, 0.0f, 1.0f);
        camera.fov = lerp(40.0f, 57.0f, speedFactor);
        game.postProcessingRenderer.radialBlurAmount = lerp(0.0f, 0.05f, speedFactor);
        
        // Feed camera data to 3D listener
        audio.set3dListenerPosition(camera.positionAbsolute.x, camera.positionAbsolute.y, camera.positionAbsolute.z);
        audio.set3dListenerAt(camera.directionAbsolute.x, camera.directionAbsolute.y, camera.directionAbsolute.z);
        audio.set3dListenerUp(camera.upAbsolute.x, camera.upAbsolute.y, camera.upAbsolute.z);
        audio.update3dAudio();
        
        updateText(speedKMH);
    }
    
    float rpmFactor = 0.0f;
    
    char[100] txt;
    void updateText(float speed)
    {
        uint fps = cast(int)(1.0 / eventManager.deltaTime);
        uint speedInt = cast(int)speed;
        uint n = sprintf(txt.ptr, "Speed: %u km/h | gear: %u | RPM: %f | thr: %f | clt: %f", speedInt, car.gear + 1, car.rpm, car.throttle, car.clutch);
        string s = cast(string)txt[0..n];
        text.setText(s);
    }
}

class VehicleDemoGame: Game
{
    Soloud audio;
    
    this(uint w, uint h, bool fullscreen, string title, string[] args)
    {
        super(w, h, fullscreen, title, args);
        audio = Soloud.create();
        audio.init(Soloud.CLIP_ROUNDOFF | Soloud.LEFT_HANDED_3D);
        currentScene = New!GameScene(this);
        
        /*
        int num = SDL_NumJoysticks();
        for (int i = 0; i < num; i++) {
            logInfo(i, ": ", SDL_JoystickNameForIndex(i).to!string);
        }
        SDL_Joystick* wheel = SDL_JoystickOpen(1);
        if (wheel is null) {
            logInfo("Joystick open error: ", SDL_GetError().to!string);
        }
        SDL_JoystickEventState(SDL_ENABLE);
        SDL_JoystickType type = SDL_JoystickGetType(wheel);
        logInfo("Type: ", type);
        logInfo("SDL_JOYSTICK_TYPE_WHEEL: ", SDL_JOYSTICK_TYPE_WHEEL);
        char[33] guidStr;
        SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(wheel), guidStr.ptr, guidStr.length);
        logInfo("GUID: ", guidStr);
        */
    }
}

void main(string[] args)
{
    import loader = bindbc.loader.sharedlib;
    NewtonSupport sup = loadNewton();
    foreach(info; loader.errors)
    {
        writeln(info.error.to!string, " ", info.message.to!string);
    }
    
    loadSoloud();
    
    VehicleDemoGame game = New!VehicleDemoGame(1280, 720, false, "Chillwave Drive", args);
    game.run();
    Delete(game);
    
    logDebug("Leaked memory: ", allocatedMemory);
}
