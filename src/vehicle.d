/*
Copyright (c) 2021-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module vehicle;

import std.stdio;
import std.algorithm;
import std.math;
import dagon;
import dagon.ext.newton;
import wheel;

Vector3f boxInertia(Vector3f halfSize, float mass)
{
    float x2 = halfSize.x * halfSize.x;
    float y2 = halfSize.y * halfSize.y;
    float z2 = halfSize.z * halfSize.z;
    float Ixx = (mass / 3.0) * (y2 + z2);
    float Iyy = (mass / 3.0) * (x2 + z2);
    float Izz = (mass / 3.0) * (x2 + y2);
    return Vector3f(Ixx, Iyy, Izz);
}

/// Simulates a simple vehicle with an arbitrary number of wheels.
class Vehicle: EntityComponent
{
    NewtonPhysicsWorld world;
    NewtonCollisionShape chassisShape;
    NewtonRigidBody chassisBody;
    Array!Wheel wheels;
    
    float torqueDirection = 1.0f; // -1.0f or 1.0f
    float steeringInput = 0.0f; // -1.0f..1.0f
    float maxSteeringAngle = 45.0f;
    
    float maxTorque = 500.0f;
    float rpmIdle = 800.0f;
    float rpmPeakTorquePoint = 5500.0f;
    float rpmRedline = 8000.0f;
    float rpmMax = 8500.0f;
    float rpm = 0.0f;
    
    float[] gears = [3.23f, 2.19f, 1.71f, 1.39f, 1.16f, 0.93f];
    float reverseGear = -3.0f;
    float[] upshiftRPM = [6500, 6500, 6500, 6500, 6500, 6500];
    float[] downshiftRPM = [0, 3000, 3000, 3000, 3000, 3000];
    uint gear = 0;
    float gearRatio = 0.0f;
    float finalDriveRatio = 2.37f;
    float drivetrainEfficiency = 0.99f;
    
    float throttle = 0.0f; // 0.0f..1.0f
    float clutch = 0.0f; // 0.0f..1.0f
    
    bool accelerating = false;
    bool brake = false;
    float movementDirection = 0.0f;
    
    Matrix4x4f prevTransformation;
    
    this(NewtonPhysicsWorld world, Entity entity, NewtonCollisionShape shape, float mass, int materialID)
    {
        super(world.eventManager, entity);
        this.world = world;
        
        this.chassisShape = shape;
        
        this.chassisBody = world.createDynamicBody(this.chassisShape, mass);
        this.chassisBody.position = entity.position;
        this.chassisBody.rotation = entity.rotation;
        this.chassisBody.transformation =
            translationMatrix(entity.position) *
            entity.rotation.toMatrix4x4;
        this.chassisBody.raycastable = false;
        this.chassisBody.groupId = materialID;
        
        NewtonBodySetContinuousCollisionMode(chassisBody.newtonBody, 1);
        NewtonBodySetMatrix(chassisBody.newtonBody, chassisBody.transformation.arrayof.ptr);
        
        NewtonMaterialSetDefaultFriction(world.newtonWorld, 0, materialID, 0.2f, 0.2f);
        NewtonMaterialSetDefaultElasticity(world.newtonWorld, 0, materialID, 0.2f);
        
        prevTransformation = Matrix4x4f.identity;
        
        gearRatio = gears[0];
    }
    
    ~this()
    {
        wheels.free();
    }
    
    Wheel addWheel(Vector3f suspensionPosition, float radius, float facing)
    {
        Wheel wheel = New!Wheel(suspensionPosition, facing, this);
        wheel.radius = radius;
        wheels.append(wheel);
        return wheel;
    }
    
    void setInertia(float mass, Vector3f itertia)
    {
        NewtonBodySetMassMatrix(chassisBody.newtonBody, mass, itertia.x, itertia.y, itertia.z);
    }
    
    Vector3f position() @property
    {
        return chassisBody.position.xyz;
    }
    
    Quaternionf rotation() @property
    {
        return chassisBody.rotation;
    }
    
    Matrix4x4f transformation() @property
    {
        return chassisBody.transformation;
    }
    
    Vector3f longitudinalAxis()
    {
        return chassisBody.transformation.forward;
    }
    
    Vector3f lateralAxis()
    {
        return chassisBody.transformation.right;
    }
    
    Vector3f verticalAxis()
    {
        return chassisBody.transformation.up;
    }
    
    Vector3f velocity() @property
    {
        return chassisBody.velocity;
    }
    
    float speed() @property
    {
        return chassisBody.velocity.length;
    }
    
    float speedKMH() @property
    {
        float averageWheelsVelocity = 0.0f;
        foreach(w; wheels)
        {
            averageWheelsVelocity += abs(w.longitudinalSpeed) * w.torqueSplitRatio;
        }
        
        return averageWheelsVelocity * 3.6f;
    }
    
    void accelerate(float direction, float delta)
    {
        brake = (movementDirection < 0.0f && direction > 0.0f) ||
                (movementDirection > 0.0f && direction < 0.0f);
        
        if (!brake)
        {
            if (direction < 0.0f)
            {
                gear = 0;
                gearRatio = reverseGear;
            }
            else
                gearRatio = gears[gear];
            
            accelerating = true;
        }
    }
    
    void idle()
    {
        accelerating = false;
        brake = false;
    }
    
    void steer(float input)
    {
        steeringInput += input;
        
        if (steeringInput > 1.0f)
            steeringInput = 1.0f;
        if (steeringInput < -1.0f)
            steeringInput = -1.0f;
    }
    
    float lateralSpeedKMH() @property
    {
        Vector3f rightVector = chassisBody.transformation.right;
        return abs(dot(chassisBody.velocity, rightVector)) * 3.6;
    }
    
    float longitudinalSpeedKMH() @property
    {
        Vector3f forwardVector = chassisBody.transformation.forward;
        return abs(dot(chassisBody.velocity, forwardVector)) * 3.6;
    }
    
    float lateralSlip() @property
    {
        float lateralSpeed = abs(dot(chassisBody.velocity, chassisBody.transformation.right));
        return clamp((lateralSpeed - 6.0f) / 6.0f, 0.0f, 1.0f);
    }
    
    float longitudinalSlip() @property
    {
        if (brake) return 1.0f;
        
        float res = 0.0f;
        foreach(wheel; wheels)
        {
            if (wheel.onGround)
            {
                res += clamp(wheel.slipRatio, 0.0f, 1.0f);
            }
        }
        return res / wheels.length;
    }
    
    /**
     * A: peak magnitude
     * B: curve baseline y
     * C: ends slope
     * D: peak RPM
     * F: ends slope
     */
    float engineTorqueCurve(float rpm)
    {
        const float A = maxTorque;
        const float B = 0.0f;
        const float C = 0.95f;
        const float D = rpmPeakTorquePoint;
        const float F = 3000.0f;
        return (A - B) * exp(-pow((rpm - D) * C, 2.0f) / (F * F)) + B;
    }
    
    override void update(Time t)
    {
        float ackermann = 5.0f;
        float steeringAngleInner = maxSteeringAngle * steeringInput;
        float steeringAngleOuter = (maxSteeringAngle - ackermann) * steeringInput;
        
        if (steeringInput < 0.0f)
        {
            wheels[0].steeringAngle = steeringAngleInner;
            wheels[1].steeringAngle = steeringAngleOuter;
        }
        else
        {
            wheels[0].steeringAngle = steeringAngleOuter;
            wheels[1].steeringAngle = steeringAngleInner;
        }
        
        float carSpeed = speedKMH();
        
        float transmissionRatio = abs(gearRatio) * finalDriveRatio * drivetrainEfficiency;
        
        const float clutchCurve = 5.0f;
        const float engineInertia = 6.0f;
        
        float effectiveClutch = pow(clutch, clutchCurve);
        float effectiveRadius = wheels[3].radius;
        float rpmWheel = carSpeed * 1000.0f / (60.0f * 2.0f * PI * effectiveRadius);
        float rpmClutch = rpmWheel * transmissionRatio;
        float rpmFree = lerp(rpmIdle, rpmMax, throttle);
        rpm = lerp(
            max2(rpmIdle, rpmClutch),
            max3(rpmIdle, (rpmFree - rpmClutch) / engineInertia, rpmClutch),
            effectiveClutch);
        float engineTorque = engineTorqueCurve(rpm) * throttle;
        float axleTorque = sign(gearRatio) * engineTorque * effectiveClutch * transmissionRatio;
        
        foreach(w; wheels)
        {
            if (accelerating)
                w.torque = axleTorque * w.torqueSplitRatio;
            else
                w.torque = 0.0f;
            w.brake = brake;
            w.update(t.delta);
        }
        
        // Automatic gearbox (kind of)
        if (accelerating)
        {
            if (throttle < 1.0f)
                throttle += t.delta;
            else
                throttle = 1.0f;
            
            if (rpm >= upshiftRPM[gear] && gear < gears.length - 1)
            {
                gear++;
                gearRatio = gears[gear];
                clutch = 0.0f;
            }
            
            clutch += t.delta;
            if (clutch > 1.0f)
                clutch = 1.0f;
        }
        else
        {
            throttle -= t.delta;
            if (throttle < 0.0f)
                throttle = 0.0f;
            
            if (rpm <= downshiftRPM[gear] && gear > 0)
            {
                gear--;
                gearRatio = gears[gear];
                clutch = 0.0f;
            }
        }
        
        if (brake)
        {
            clutch -= t.delta;
            if (clutch < 0.0f)
                clutch = 0.0f;
        }
        
        chassisBody.update(t.delta);

        entity.prevTransformation = prevTransformation;

        entity.position = chassisBody.position.xyz;
        entity.transformation = chassisBody.transformation * scaleMatrix(entity.scaling);
        entity.invTransformation = entity.transformation.inverse;
        entity.rotation = chassisBody.rotation;

        entity.absoluteTransformation = entity.transformation;
        entity.invAbsoluteTransformation = entity.invTransformation;
        entity.prevAbsoluteTransformation = entity.prevTransformation;

        prevTransformation = entity.transformation;
        
        float steeringDecreaseStep = 1.8f * t.delta;
        if (steeringInput > steeringDecreaseStep)
            steeringInput -= steeringDecreaseStep;
        else if (steeringInput < -steeringDecreaseStep)
            steeringInput += steeringDecreaseStep;
        else
            steeringInput = 0.0f;
        
        movementDirection = (dot(velocity.normalized, longitudinalAxis) < 0.0f)? -1.0f : 1.0f;
    }
}

float rpmFromAngularVelocity(float omega) { return omega * 60.0f / (2.0f * PI); }
float angularVelocityFromRpm(float rpm) { return rpm * 2.0f * PI / 60.0f; }
