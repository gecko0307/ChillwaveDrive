/*
Copyright (c) 2021-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module wheel;

import std.stdio;
import std.algorithm;
import std.math;
import dagon;
import dagon.ext.newton;
import vehicle;
import pacejka;

struct Suspension
{
    float minLength;
    float restLength;
    float maxLength;
    float stiffness; 
    float damping;
    float compression;
    float length;
    float lengthPrev;
}

/// Simulates a single raycast wheel, includes suspension and tyre models.
class Wheel: Owner, NewtonRaycaster
{
    Vehicle vehicle;
    Vector3f position = Vector3f(0.0f, 0.0f, 0.0f);
    Suspension suspension;
    float radius = 0.35f;
    float mass = 25.0f;
    float stiffness = 200000.0f;
    float steeringAngle = 0.0f;
    float camberAngle = 0.0f;
    float facing = 0.0f;
    float normalForce = 0.0f;
    float lateralFrictionForce = 0.0f;
    float staticLateralFrictionForce = 0.0f;
    float longitudinalFrictionForce = 0.0f;
    float load = 0.25f;
    float slipAngle = 0.0f;
    float slipRatio = 0.0f;
    float torque = 0.0f;
    float torqueSplitRatio = 0.0f;
    float angularAcceleration = 0.0f;
    float angularVelocity = 0.0f;
    float roll = 0.0f;
    float invInertia = 1.0f;
    float staticFrictionCoefficient = 0.99f;
    float lateralDynamicFrictionCoefficient = 1.0f;
    float longitudinalDynamicFrictionCoefficient = 1.0f;
    Quaternionf steering = Quaternionf.identity;
    bool brake = false;
    
    float longitudinalSpeed = 0.0f;
    
    float maxRayDistance = 1000.0f;
    protected float closestHitRayParam = 1.0f;
    Vector3f groundPosition;
    Vector3f groundNormal;
    bool onGround = false;
    
    PacejkaModel tyreModel;
    
    float visualSuspensionLength;
    float visualSuspensionChangeSpeed = 5.0f;
    
    float forcePoint = 0.0f;
    
    this(Vector3f position, float facing, Vehicle vehicle)
    {
        super(vehicle);
        this.vehicle = vehicle;
        this.position = position;
        this.facing = facing;
        
        suspension.minLength = 0.28f;
        suspension.maxLength = 0.3f;
        suspension.stiffness = 100.0f;
        suspension.damping = 10.0f;
        suspension.compression = 0.0f;
        suspension.length = 0.0f;
        suspension.lengthPrev = 0.0f;
        
        visualSuspensionLength = suspension.maxLength;
        
        tyreModel.a0 = 1.28f;    // Shape factor (1.4..1.8)
        tyreModel.a1 = -28.0f;   // Load influence on lateral friction coefficient, 1/kN (-80..+80)
        tyreModel.a2 = 1200.0f;  // Lateral friction coefficient (900..1700)
        tyreModel.a3 = 1900.0f;  // Change of stiffness with slip, N/deg (500..2000)
        tyreModel.a4 = 8.0f;     // Change of progressivity of stiffness / load, 1/kN (0..50)
        tyreModel.a5 = 0.015f;   // Camber influence on stiffness, %/deg/100 (-0.1..+0.1)
        tyreModel.a6 = -0.25f;   // Curvature change with load (-2..+2)
        tyreModel.a7 = 0.1f;     // Curvature factor (-20..+1)
        tyreModel.a8 = -0.03f;   // Load influence on horizontal shift, deg/kN (-1..+1)
        tyreModel.a9 = -0.001f;  // Horizontal shift at load = 0 and camber = 0, deg (-1..+1)
        tyreModel.a10 = -0.15f;  // Camber influence on horizontal shift, deg/deg (-0.1..+0.1)
        tyreModel.a11 = 0.0f;    // Vertical shift, N (-200..+200)
        tyreModel.a12 = 17.8f;   // Vertical shift at load, N = 0 (-10..+10)
        tyreModel.a13 = -2.4f;   // Camber influence on vertical shift, load dependent, N/deg/kN (-10..+10)
        tyreModel.a14 = 0.0f;    // Camber influence on vertical shift, N/deg (-15..+15)
        tyreModel.a15 = 0.0f;    // Camber influence on lateral friction coefficient, 1/deg (-0.01..+0.01)
        tyreModel.a16 = 0.0f;    // Curvature change with camber (-0.1..+0.1)
        tyreModel.a17 = 0.0f;    // Curvature shift (-1..+1)
        
        tyreModel.b0 = 1.36f;    // Shape factor (1.4..1.8)
        tyreModel.b1 = -40.0f;   // Load influence on longitudinal friction coefficient, 1/kN (-80..+80)
        tyreModel.b2 = 1650.0f;  // Longitudinal friction coefficient (900..1700)
        tyreModel.b3 = 40.0f;    // Curvature factor of stiffness/load, N/%/kN^2 (-20..+20)
        tyreModel.b4 = 240.0f;   // Change of stiffness with slip, N/% (100..500)
        tyreModel.b5 = 0.08f;    // Change of progressivity of stiffness/load, 1/kN (-1..+1)
        tyreModel.b6 = -0.05f;   // Curvature change with load^2 (-0.1..+0.1)
        tyreModel.b7 = 0.05f;    // Curvature change with load (-1..+1)
        tyreModel.b8 = -0.025f;  // Curvature factor (-20..+1)
        tyreModel.b9 = 0.015f;   // Load influence on horizontal shift, %/kN (-1..+1)
        tyreModel.b10 = 0.4f;    // Horizontal shift, % (-5..+5)
        tyreModel.b11 = -50.0f;  // Vertical shift, N (-100..+100)
        tyreModel.b12 = 0.0f;    // Vertical shift at load = 0, N (-10..+10)
        tyreModel.b13 = 0.0f;    // Curvature shift (-1..+1)
    }
    
    float onRayHit(NewtonRigidBody nbody, Vector3f hitPoint, Vector3f hitNormal, float t)
    {
        if (t < closestHitRayParam)
        {
            groundPosition = hitPoint;
            groundNormal = hitNormal;
            closestHitRayParam = t;
            return t;
        }
        else
        {
            return 1.0f;
        }
    }
    
    bool raycast(Vector3f pstart, Vector3f pend)
    {
        closestHitRayParam = 1.0f;
        vehicle.world.raycast(pstart, pend, this);
        groundPosition = pstart + (pend - pstart).normalized * maxRayDistance * closestHitRayParam;
        return (closestHitRayParam < 1.0f);
    }
    
    void update(double dt)
    {
        invInertia = 1.0f / (mass * radius * radius);
        
        camberAngle = clamp(camberAngle, -4.0f, 4.0f);
        
        Vector3f upVectorWorld = verticalAxis();
        Vector3f rayDir = -upVectorWorld;
        Vector3f suspPosition = position * vehicle.chassisBody.transformation;
        
        steering = rotationQuaternion!float(Axis.y, degtorad(steeringAngle));
        
        Vector3f forwardAxis = longitudinalAxis();
        Vector3f sideAxis = lateralAxis();
        
        bool hitGround = raycast(suspPosition, suspPosition + rayDir * maxRayDistance);
        if (!hitGround)
        {
            hitGround = true;
            groundPosition = suspPosition;
            groundPosition.y = 0.0f;
            groundNormal = Vector3f(0.0f, 1.0f, 0.0f);
        }
        
        float suspToGround = distance(suspPosition, groundPosition);
        
        Vector3f forcePosition = groundPosition + Vector3f(0.0f, forcePoint, 0.0f);
        
        if (!hitGround || (suspToGround > suspension.maxLength + radius)) // wheel is in air
        {
            onGround = false;
            
            suspension.lengthPrev = suspension.maxLength;
            suspension.length = suspension.maxLength;
            suspension.compression = 0.0f;
            
            normalForce = 0.0f;
            lateralFrictionForce = 0.0f;
            longitudinalFrictionForce = 0.0f;
            
            slipAngle = 0.0f;
            slipRatio = 0.0f;
            
            angularAcceleration = 0.0f;
            
            if (abs(torque) > 0.0f)
                angularVelocity = torque / radius * invInertia * dt;
            else
                angularVelocity *= 0.99f; // drag
            
            Vector3f wheelVelocity = vehicle.chassisBody.pointVelocity(suspPosition);
            longitudinalSpeed = dot(wheelVelocity, forwardAxis);
        }
        else // suspension is compressed
        {
            onGround = true;
            
            float effectiveMass = vehicle.sprungMass * load;
            float xStat = (effectiveMass * 9.81f) / suspension.stiffness;
            suspension.restLength = suspension.maxLength - xStat;
            
            suspension.lengthPrev = suspension.length;
            suspension.length = clamp(suspToGround - radius, suspension.minLength, suspension.maxLength);
            suspension.compression = max2(suspension.restLength - suspension.length, 0.0f);
            
            // Normal force
            float springForce = suspension.compression * suspension.stiffness;
            float compressionSpeed = suspension.lengthPrev - suspension.length;
            float dampingForce = (compressionSpeed * suspension.damping) / dt;
            float suspensionForce = springForce + dampingForce;
            vehicle.chassisBody.addForceAtPos(groundNormal * suspensionForce, suspPosition);
            float unsprungMass = vehicle.unsprungMass / cast(float)vehicle.wheels.length;
            normalForce = suspensionForce + unsprungMass * 9.81f;
            
            float chassisSpeed = vehicle.speed;
            Vector3f chassisVelocity = vehicle.velocity;
            Vector3f wheelVelocity = vehicle.chassisBody.pointVelocity(forcePosition);
            float wheelSpeed = wheelVelocity.length;
            float lateralSpeed = dot(wheelVelocity, sideAxis);
            float longitudinalDir = (dot(vehicle.chassisBody.velocity.normalized, forwardAxis) > 0.0f) ? 1.0f : -1.0f;
            
            longitudinalSpeed = dot(wheelVelocity, forwardAxis);
            
            if (brake)
            {
                // Block the wheel
                angularAcceleration = 0.0f;
                angularVelocity = 0.0f;
                slipRatio = 100.0f;
            }
            else if (abs(torque) > 0.0f)
            {
                // Apply torque
                angularAcceleration = torque / radius * invInertia;
                angularVelocity = max2(angularVelocity, longitudinalSpeed / radius * invInertia);
                slipRatio = -12.8f;
            }
            else
            {
                // Free spin
                angularVelocity = longitudinalSpeed / radius * invInertia;
                angularAcceleration = 0.0f;
                slipRatio = 0.0f;
                angularVelocity *= 0.99f;
            }
            
            slipAngle = atan(lateralSpeed / max2(abs(longitudinalSpeed), 0.00001f));
            
            // Friction force
            float idleThreshold = 0.5f;
            // speedFactor interpolates between static (0.0) and dynamic (1.0) friction
            float speedFactor = clamp(wheelSpeed / idleThreshold, 0.0f, 1.0f);
            float wheelLoad = vehicle.totalMass * load;
            float staticLateralFrictionForce = lateralSpeed / dt * wheelLoad * staticFrictionCoefficient;
            float dynamicLateralFrictionForce = tyreModel.lateralForce(normalForce, slipAngle, degtorad(camberAngle)) * lateralDynamicFrictionCoefficient;
            lateralFrictionForce = lerp(staticLateralFrictionForce, dynamicLateralFrictionForce, speedFactor);
            longitudinalFrictionForce = tyreModel.longitudinalForce(normalForce, slipRatio) * longitudinalDynamicFrictionCoefficient;

            vehicle.chassisBody.addForceAtPos(-sideAxis * lateralFrictionForce, forcePosition);
            vehicle.chassisBody.addForceAtPos(-forwardAxis * longitudinalDir * longitudinalFrictionForce, forcePosition);
        }
        
        angularVelocity += angularAcceleration * dt;
        
        roll += angularVelocity * dt;
        roll = fmod(roll, 2.0f * PI);
        
        visualSuspensionLength += (suspension.length - visualSuspensionLength) * dt * visualSuspensionChangeSpeed;
    }
    
    Vector3f verticalAxis()
    {
        return vehicle.verticalAxis;
    }
    
    Vector3f lateralAxis()
    {
        return steering.rotate(vehicle.lateralAxis * facing).normalized;
    }
    
    Vector3f longitudinalAxis()
    {
        return steering.rotate(vehicle.longitudinalAxis).normalized;
    }
    
    Vector3f localWheelPosition()
    {
        return position - Vector3f(0.0f, visualSuspensionLength, 0.0f);
    }
    
    Quaternionf localRotation()
    {
        float facingAngle = 90.0f - 90.0f * facing;
        return
            rotationQuaternion!float(Axis.y, degtorad(facingAngle + steeringAngle)) *
            rotationQuaternion!float(Axis.z, degtorad(-camberAngle)) *
            rotationQuaternion!float(Axis.x, roll * facing);
    }
}
