/*
Copyright (c) 2021-2022 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module wheel;

import std.stdio;
import std.math;

import dlib.core.ownership;
import dlib.core.memory;
import dlib.math.vector;
import dlib.math.quaternion;
import dlib.math.transformation;
import dlib.math.utils;

import dagon.ext.newton;

import pacejka;
import vehicle;

class WheelConstraint: NewtonUserJointConstraint
{
    Wheel wheel;
    
    this(Wheel wheel)
    {
        super(wheel.world, wheel.vehicle.chassisBody, null, 2);
        this.wheel = wheel;
    }
    
    override void submit(float timestep, int threadIndex)
    {
        if (wheel.normalForce > 0.0f)
        {
            Vector3f forcePosition = wheel.getContactPoint();
            Vector3f lateralAxis = wheel.getLateralAxis();
            float frictionForce = wheel.getFrictionForce();
            
            if (frictionForce > 0.0)
            {
                addLinearRow(forcePosition, forcePosition, lateralAxis);
                setMaximumFriction(frictionForce);
                setMinimumFriction(-frictionForce);
            }
        }
    }
}

struct Suspension
{
    Vector3f position;
    float minLength;
    float maxLength;
    float stiffness; 
    float damping;
    float compression;
    float length;
    float lengthPrev;
}

class Wheel: Owner, NewtonRaycaster
{
    NewtonPhysicsWorld world;
    Vehicle vehicle;
    Suspension suspension;
    Vector3f tyreOffset;
    Vector3f position;
    Vector3f groundPosition;
    Vector3f groundNormal;
    float radius;
    float steeringAngle;
    float maxSteeringAngle;
    float slipAngle;
    float slipRatio;
    float torque;
    float roll;
    float rollSpeed;
    float normalForce;
    float facing; // 1 or -1
    float grip;
    float rollingFriction;
    float brakeFriction;
    float maxRayDistance;
    float positionSmoothFactor;
    bool isPowered;
    bool isSteered;
    bool brake;
    bool isDrifting;
    WheelConstraint joint;
    PacejkaModel tyreModel;
    
    this(Vehicle vehicle)
    {
        super(vehicle);
        this.world = vehicle.world;
        this.vehicle = vehicle;
        suspension.position = Vector3f(0.0f, 0.0f, 0.0f);
        suspension.minLength = 0.1f;
        suspension.maxLength = 0.2f;
        suspension.stiffness = 40.0f;
        suspension.damping = 6.0f;
        suspension.compression = 0.0f;
        suspension.length = 0.0f;
        suspension.lengthPrev = 0.0f;
        tyreOffset = Vector3f(0.0f, 0.0f, 0.0f);
        position = Vector3f(0.0f, 0.0f, 0.0f);
        groundPosition = Vector3f(0.0f, 0.0f, 0.0f);
        groundNormal = Vector3f(0.0f, 1.0f, 0.0f);
        radius = 0.5f;
        steeringAngle = 0.0f;
        maxSteeringAngle = 30.0f;
        slipAngle = 0.0f;
        slipRatio = 0.0f;
        torque = 0.0f;
        roll = 0.0f;
        rollSpeed = 0.0f;
        normalForce = 0.0f;
        facing = 1.0f;
        grip = 1.0f;
        rollingFriction = 0.01f;
        brakeFriction = 0.4f;
        maxRayDistance = 10000.0f;
        positionSmoothFactor = 0.4f;
        isPowered = false;
        brake = false;
        isDrifting = false;
        joint = New!WheelConstraint(this);
    }
    
    protected float closestHit = 1.0f;
    
    float onRayHit(NewtonRigidBody nbody, Vector3f hitPoint, Vector3f hitNormal, float t)
    {
        if (t < closestHit)
        {
            groundPosition = hitPoint;
            groundNormal = hitNormal;
            closestHit = t;
            return t;
        }
        else
        {
            return 1.0f;
        }
    }
    
    bool raycast(Vector3f pstart, Vector3f pend)
    {
        closestHit = 1.0f;
        world.raycast(pstart, pend, this);
        groundPosition = pstart + (pend - pstart).normalized * maxRayDistance * closestHit;
        return (closestHit < 1.0f);
    }
    
    void update(double dt)
    {
        Vector3f upVectorW = vehicle.chassisBody.transformation.up;
        Vector3f downVectorW = -upVectorW;
        Vector3f forwardVectorW = vehicle.chassisBody.transformation.forward;
        Vector3f rightVectorW = vehicle.chassisBody.transformation.right;
        
        Vector3f suspPositionW = suspension.position * vehicle.chassisBody.transformation;
        
        Vector3f raycastPos = (suspension.position + tyreOffset) * vehicle.chassisBody.transformation;
        bool hitGround = raycast(raycastPos, raycastPos + downVectorW * maxRayDistance);
        float suspToGround = distance(raycastPos, groundPosition);
        
        auto steering = rotationQuaternion!float(Axis.y, degtorad(steeringAngle));
        
        Vector3f sideAxis = getLateralAxis();
        Vector3f forwardAxis = steering.rotate(forwardVectorW).normalized;
        float forwardSpeed = dot(vehicle.chassisBody.velocity, forwardAxis);
        
        Vector3f wheelVelocity = vehicle.chassisBody.pointVelocity(groundPosition);
        
        float lateralSpeed = dot(wheelVelocity, sideAxis);
        float longitudinalSpeed = dot(wheelVelocity, forwardAxis) - rollSpeed * radius;
        
        slipAngle = atan2(lateralSpeed, longitudinalSpeed);
        slipRatio = abs(rollSpeed * radius) / max2(abs(longitudinalSpeed), 0.00001f);
        
        if (!hitGround || (suspToGround > suspension.maxLength + radius)) // wheel is in air
        {
            suspension.lengthPrev = suspension.maxLength;
            suspension.length = suspension.maxLength;
            suspension.compression = 0.0f;
            
            normalForce = 0.0f;
            
            if (isPowered && abs(torque))
                rollSpeed = torque * dt;
            else
                rollSpeed = 0.0f;
        }
        else // suspension is compressed
        {
            suspension.lengthPrev = suspension.length;
            suspension.length = suspToGround - radius;
            if (suspension.length < suspension.minLength)
                suspension.length = suspension.minLength;
            suspension.compression = suspension.maxLength - suspension.length;
            
            float wheelLoad = vehicle.chassisBody.mass / cast(float)vehicle.wheels.length;
            float springForce = suspension.compression * suspension.stiffness;
            float compressionSpeed = suspension.lengthPrev - suspension.length;
            float dampingForce = (compressionSpeed * suspension.damping) / dt;
            normalForce = (springForce + dampingForce) * wheelLoad;
            
            vehicle.chassisBody.addForceAtPos(upVectorW * normalForce, suspPositionW);
            
            Vector3f forcePosition = getContactPoint();
            
            if (isPowered)
            {
                float forwardForce = torque / radius;
                vehicle.chassisBody.addForceAtPos(forwardAxis * forwardForce, forcePosition);
            }
            
            if (brake)
            {
                float brakeForce = normalForce / radius * brakeFriction;
                Vector3f brakeForceDir = -sign(forwardSpeed) * forwardAxis;
                vehicle.chassisBody.addForceAtPos(brakeForceDir * brakeForce, forcePosition);
            }
            
            rollSpeed = forwardSpeed * 0.8f / radius;
        }
        
        Vector3f newWheelPos = (suspension.position + tyreOffset) - Vector3f(0.0f, suspension.length, 0.0f);
        position += (newWheelPos - position) * positionSmoothFactor;
        
        if (!brake)
        {
            roll += radtodeg(rollSpeed) * dt;
            if (roll > 360.0f)
                roll -= 360.0f;
        }
        
        float steeringDecreaseStep = 2.0f;
        if (steeringAngle > steeringDecreaseStep)
            steeringAngle -= steeringDecreaseStep;
        else if (steeringAngle < -steeringDecreaseStep)
            steeringAngle += steeringDecreaseStep;
        else
            steeringAngle = 0.0f;
    }
    
    Vector3f getLateralAxis() 
    {
        auto steering = rotationQuaternion!float(Axis.y, degtorad(steeringAngle));
        return steering.rotate(vehicle.chassisBody.transformation.right) * facing;
    }
    
    Vector3f getLongitudinalAxis() 
    {
        auto steering = rotationQuaternion!float(Axis.y, degtorad(steeringAngle));
        return steering.rotate(vehicle.chassisBody.transformation.forward);
    }
    
    Vector3f getContactPoint()
    {
        Vector3f contactPoint = (suspension.position + tyreOffset) - Vector3f(0.0f, radius, 0.0f);
        Vector3f forcePosition = contactPoint * vehicle.chassisBody.transformation;
        return forcePosition;
    }
    
    float getFrictionForce()
    {
        float lateralFriction = tyreModel.lateralForce(normalForce, abs(slipAngle), 0.0f);
        float longitudinalFriction = tyreModel.longitudinalForce(normalForce, slipRatio);
        
        float maxFrictionForce = normalForce * grip;
        float invMag2 = maxFrictionForce / sqrt(lateralFriction * lateralFriction + longitudinalFriction * longitudinalFriction);
        float frictionForce = lateralFriction * invMag2;
        return frictionForce;
    }
    
    Quaternionf rotation()
    {
        float facingRotation = 180.0f * cast(float)(facing > 0.0f);
        Quaternionf r =
            rotationQuaternion(Axis.y, degtorad(facingRotation + steeringAngle)) *
            rotationQuaternion(Axis.x, degtorad(-facing * roll));
        return r;
    }
}
