/*
Copyright (c) 2021-2025 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module wheel;

import std.stdio;
import std.algorithm;
import std.math;
import dagon;
import dagon.ext.newton;
import vehicle;
import pacejka;

struct Suspension
{
    float minLength;
    float maxLength;
    float stiffness; 
    float damping;
    float compression;
    float length;
    float lengthPrev;
}

/// Simulates a single raycast wheel, includes suspension and tyre models.
class Wheel: Owner, NewtonRaycaster
{
    Vehicle vehicle;
    Vector3f position = Vector3f(0.0f, 0.0f, 0.0f);
    Suspension suspension;
    float radius = 0.35f;
    float steeringAngle = 0.0f;
    float camberAngle = 0.0f;
    float facing = 0.0f;
    float normalForce = 0.0f;
    float tractionForce = 0.0f;
    float lateralFrictionForce = 0.0f;
    float staticLateralFrictionForce = 0.0f;
    float longitudinalFrictionForce = 0.0f;
    float load = 0.25f;
    float slipAngle = 0.0f;
    float slipRatio = 0.0f;
    float torque = 0.0f;
    float torqueSplitRatio = 0.0f;
    float angularAcceleration = 0.0f;
    float angularVelocity = 0.0f;
    float roll = 0.0f;
    float invInertia = 0.99f;
    float staticFrictionCoefficient = 0.99f;
    float lateralDynamicFrictionCoefficient = 1.0f;
    float longitudinalDynamicFrictionCoefficient = 1.0f;
    Quaternionf steering = Quaternionf.identity;
    bool brake = false;
    
    float longitudinalSpeed = 0.0f;
    
    float maxRayDistance = 1000.0f;
    protected float closestHitRayParam = 1.0f;
    Vector3f groundPosition;
    Vector3f groundNormal;
    bool onGround = false;
    
    PacejkaModel tyreModel;
    
    float visualSuspensionLength;
    float visualSuspensionChangeSpeed = 2.0f;
    
    float forcePoint = 0.03f;
    
    this(Vector3f position, float facing, Vehicle vehicle)
    {
        super(vehicle);
        this.vehicle = vehicle;
        this.position = position;
        this.facing = facing;
        
        suspension.minLength = 0.0f;
        suspension.maxLength = 0.3f;
        suspension.stiffness = 100.0f;
        suspension.damping = 10.0f;
        suspension.compression = 0.0f;
        suspension.length = 0.0f;
        suspension.lengthPrev = 0.0f;
        
        visualSuspensionLength = suspension.maxLength;
    }
    
    float onRayHit(NewtonRigidBody nbody, Vector3f hitPoint, Vector3f hitNormal, float t)
    {
        if (t < closestHitRayParam)
        {
            groundPosition = hitPoint;
            groundNormal = hitNormal;
            closestHitRayParam = t;
            return t;
        }
        else
        {
            return 1.0f;
        }
    }
    
    bool raycast(Vector3f pstart, Vector3f pend)
    {
        closestHitRayParam = 1.0f;
        vehicle.world.raycast(pstart, pend, this);
        groundPosition = pstart + (pend - pstart).normalized * maxRayDistance * closestHitRayParam;
        return (closestHitRayParam < 1.0f);
    }
    
    void update(double dt)
    {
        camberAngle = clamp(camberAngle, -4.0f, 4.0f);
        
        Vector3f upVectorWorld = verticalAxis();
        Vector3f rayDir = -upVectorWorld;
        Vector3f suspPosition = position * vehicle.chassisBody.transformation;
        
        steering = rotationQuaternion!float(Axis.y, degtorad(steeringAngle));
        
        Vector3f forwardAxis = longitudinalAxis();
        Vector3f sideAxis = lateralAxis();
        
        bool hitGround = raycast(suspPosition, suspPosition + rayDir * maxRayDistance);
        if (!hitGround)
        {
            hitGround = true;
            groundPosition = suspPosition;
            groundPosition.y = 0.0f;
            groundNormal = Vector3f(0.0f, 1.0f, 0.0f);
        }
        
        float suspToGround = distance(suspPosition, groundPosition);
        
        Vector3f forcePosition = groundPosition + Vector3f(0.0f, forcePoint, 0.0f);
        
        angularVelocity = 0.0f;
        
        if (!hitGround || (suspToGround > suspension.maxLength + radius)) // wheel is in air
        {
            onGround = false;
            
            suspension.lengthPrev = suspension.maxLength;
            suspension.length = suspension.maxLength;
            suspension.compression = 0.0f;
            
            normalForce = 0.0f;
            tractionForce = 0.0f;
            lateralFrictionForce = 0.0f;
            longitudinalFrictionForce = 0.0f;
            
            slipAngle = 0.0f;
            slipRatio = 0.0f;
            
            angularAcceleration = 0.0f;
            
            if (abs(torque) > 0.0f)
                angularVelocity = torque / radius * invInertia * dt;
            else
                angularVelocity *= 0.99f; // drag
            
            Vector3f wheelVelocity = vehicle.chassisBody.pointVelocity(suspPosition);
            longitudinalSpeed = dot(wheelVelocity, forwardAxis);
        }
        else // suspension is compressed
        {
            onGround = true;
            
            suspension.lengthPrev = suspension.length;
            suspension.length = clamp(suspToGround - radius, suspension.minLength, suspension.maxLength);
            suspension.compression = suspension.maxLength - suspension.length;
            
            // Normal force
            float wheelLoad = vehicle.chassisBody.mass * load;
            float springForce = suspension.compression * suspension.stiffness;
            float compressionSpeed = suspension.lengthPrev - suspension.length;
            float dampingForce = (compressionSpeed * suspension.damping) / dt;
            normalForce = (springForce + dampingForce) * wheelLoad;
            
            vehicle.chassisBody.addForceAtPos(groundNormal * normalForce, forcePosition);
            
            float chassisSpeed = vehicle.speed;
            Vector3f chassisVelocity = vehicle.velocity;
            Vector3f wheelVelocity = vehicle.chassisBody.pointVelocity(forcePosition);
            float wheelSpeed = wheelVelocity.length;
            float lateralSpeed = dot(wheelVelocity, sideAxis);
            float longitudinalDir = (dot(vehicle.chassisBody.velocity.normalized, forwardAxis) > 0.0f) ? 1.0f : -1.0f;
            
            longitudinalSpeed = dot(wheelVelocity, forwardAxis);
            
            if (brake)
            {
                // Block the wheel
                angularAcceleration = 0.0f;
                angularVelocity = 0.0f;
                slipRatio = 1.0f;
            }
            else if (abs(torque) > 0.0f)
            {
                // Apply torque
                tractionForce = torque / radius * invInertia;
                vehicle.chassisBody.addForceAtPos(forwardAxis * tractionForce, forcePosition);
                angularAcceleration = tractionForce;
                slipRatio = 0.0f;
                //slipRatio = clamp(abs((angularVelocity * radius) / max2(abs(longitudinalSpeed), 0.00001f)), 0.0f, 1.0f);
            }
            else
            {
                // Free spin
                angularVelocity = longitudinalSpeed / radius * invInertia;
                angularAcceleration = 0.0f;
                slipRatio = 0.0f;
                angularVelocity *= 0.99f; // drag
            }
            
            slipAngle = atan(lateralSpeed / max2(abs(longitudinalSpeed), 0.00001f));
            
            // Friction force
            float idleThreshold = 1.0f;
            // speedFactor interpolates between static (0.0) and dynamic (1.0) friction
            float speedFactor = clamp(wheelSpeed / idleThreshold, 0.0f, 1.0f);
            float staticLateralFrictionForce = lateralSpeed / dt * wheelLoad * staticFrictionCoefficient;
            float dynamicLateralFrictionForce = tyreModel.lateralForce(normalForce, slipAngle, degtorad(camberAngle)) * lateralDynamicFrictionCoefficient;
            lateralFrictionForce = lerp(staticLateralFrictionForce, dynamicLateralFrictionForce, speedFactor);
            longitudinalFrictionForce = tyreModel.longitudinalForce(normalForce, slipRatio) * longitudinalDynamicFrictionCoefficient;
            vehicle.chassisBody.addForceAtPos(-sideAxis * lateralFrictionForce, forcePosition);
            vehicle.chassisBody.addForceAtPos(-forwardAxis * longitudinalDir * longitudinalFrictionForce, forcePosition);
        }
        
        angularVelocity += angularAcceleration * dt;
        if (abs(angularVelocity) > 0.1f)
        {
            float angularVelocityVisual = clamp(angularVelocity, -10.0f, 10.0f);
            roll += angularVelocityVisual * dt;
            roll = fmod(roll, 2.0f * PI);
        }
        
        visualSuspensionLength += (suspension.length - visualSuspensionLength) * dt * visualSuspensionChangeSpeed;
    }
    
    Vector3f verticalAxis()
    {
        return vehicle.verticalAxis;
    }
    
    Vector3f lateralAxis()
    {
        return steering.rotate(vehicle.lateralAxis * facing).normalized;
    }
    
    Vector3f longitudinalAxis()
    {
        return steering.rotate(vehicle.longitudinalAxis).normalized;
    }
    
    Vector3f localWheelPosition()
    {
        return position - Vector3f(0.0f, visualSuspensionLength, 0.0f);
    }
    
    Quaternionf localRotation()
    {
        float facingAngle = 90.0f - 90.0f * facing;
        return
            rotationQuaternion!float(Axis.y, degtorad(facingAngle + steeringAngle)) *
            rotationQuaternion!float(Axis.z, degtorad(-camberAngle)) *
            rotationQuaternion!float(Axis.x, roll * facing);
    }
}
